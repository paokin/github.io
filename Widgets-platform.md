## About this document

To facilitate building front-end applications based on the Sports data API and other SBTech APIs, we have put together a reference "widget platform". You can use this package either purely as a reference or as an initial blueprint to start working on a specific feature set.

In this document we will provide a comprehensive walk-through of how to set it up and use it, along with the Sports Data API provided by SBTech, to build an example end-user facing application. We will call this application "Upcoming events widget" with the following basic features:

* The "Upcoming events widget" will present all events available for pre-match betting which start within the next 24 hours.
* Events will be grouped into sport-specific tabs
* Events in each sport tab are ordered by start time

This is, of course, an incomplete specification which can be enhanced and improved upon. But addressing even this limited set of features will provide a good understanding of how to best utilise the Sports data API. We will specifically try to answer the following questions:

* How to setup a development environment to use the Sports data API
* How to implement the Authentication flow expected by the API
* How to write queries to dynamically fetch data from the API and subscribe for updates for these queries and how to interpret the response payload and the structure of the entities.
* We will use the "Upcoming events widget" as example, limited to the features described above (full implementation might require additional features).
* We will provide short code sample where relevant.
* How to avoid the most common errors

## Authentication

The communication with the Sports Data API is executed through the HTTP and Server Sent Events (SSE) protocols. Internet Explorer and Edge are supported by long polling. To identify and validate correctly the Operator, a JWT token needs to be present in the HTTP header of all requests:

* Header: Authorization
* Value: Bearer {JWT Token}

For development and testing we will provide a token with a very long lifetime that can be used also with common tools such as Swagger. Please get in touch with your SBTech account manager to kick this process off.

In real production the token will be generated by the SBTech Authentication API. You will receive a separate documentation for it. The JWT token will verify that the call to the Sports data API (and other SBTech APIs) is authorised and, when relevant, will also contain an identifier for the user account related to the call. The latter is not relevant for the Sports data API, which doesn't include features based on user segments or user profile.

## Glossary

First let's define some terms we will be using in this document.

**Widgets Platform**: The "Widgets platform" is a set of libraries and utils required for creating a widget. It's represented as npm package `sbtech-widgets-platform`. It includes `react` and `mobx` as main app libraries, `node-polyglot` for i18n, `postal` as message bus and few other helpers (run `npm info sbtech-widgets-platform` dependencies in your terminal for more detail). Also it includes API for configuring, loading and instantiating widgets. Platform is distributed with typescript definition file, so all export could be found there.

**Widgets Scripts**: Scripts is a tool for scaffolding widgets' project (just like `create-react-app`) with scripts for building, verifying and publishing widgets of project and its' dependencies.

**Widget**: Widget is a react component that is able to communicate with some SBTech API and visualise data.

**Skin**: Skin is a stylesheet file that contain all css related to particular widget. Usually built from less files.
Skin Palette: Skin palette is set of abstract variables which you can import in the following way: `@import (less) "~@skin/variables";

## Project setup and scaffolding

Let's create a simple widget that displays upcoming games within next 24 hours. We will use Sports API of SBTech as source of data. The only required package is `sbtech-widgtes-platform`. We can create all the infrastructure manually, but it's time-consuming procedure, so will use `sbtech-widgets-scripts` package to scaffold everything we will need.

Install latest scripts globally first:

```shell
yarn global add sbtech-widgets-scripts@10.0.0-beta.36
```

And initialize the project:

```shell
cd ~/Projects
mkdir sbtech-sports-betting
cd sbtech-sports-betting
sbtech-widgets-scripts init sbtech-sports-betting
```

As a result we will have the structure for typescript based monorepository project (read this article if you are not familiar with monorepo):

```textile
sbtech-sports-betting
├── README.md
├── node_modules                                        -- external dependencies, includes platform itself and all required packages
│   ├── ...
│   ├── mobx
│   ├── react
│   ├── ...
│   ├── sbtech-changelog
│   ├── sbtech-skin-palette
│   ├── sbtech-widgets-platform
│   ├── sbtech-widgets-scripts
│   ├── ...
├── package.json                                        -- project package, includes scripts like start, build, lint, test and create-widget
├── packages                                            -- project packages will be placed here
├── pallete-extension                                   -- pallete extension, contains superset of base palette, by default it's only reexports base palette
│   └── variables.less
├── public                                              -- simple host page, used for development
│   └── index.pug
├── tsconfig.json                                       -- default typescript config, update it to fit team needs
├── tslint.json                                         -- default lint config, rules also may be modified as needed
└── yarn.lock
```

## Create sample widget

Because we scaffolded project using `sbtech-widgets-scripts` now we can create sample widget using project scripts:

```shell
yarn create-widget upcoming
```

If we check file structure we will see that new pacakge is created:

```text
sbtech-sports-betting
├── ...
├── packages
│   └── sbtech-widget-upcoming                          -- widget package, it contains own package.json file
│       ├── README.md
│       ├── locales                                     -- internationalisation files
│       │   └── en.json
│       ├── package.json                                -- dependencies should be empty, just use imports in code, everething will be added automatically on publush phase
│       └── src                                         -- code of widget, could include styles and assets
│           ├── components
│           ├── index.ts                                -- widget definition should be exported as main file
│           ├── service
│           ├── styles.less
│           ├── tid-selectors.ts
│           ├── upcoming-widget.component.test.tsx
│           ├── upcoming-widget.component.tsx
│           ├── upcoming-widget.config.test.ts
│           ├── upcoming-widget.config.ts
│           └── upcoming-widget.props.ts
├── ...
```

To check that everething works fine run dev server:

```shell
yarn start
```

And open the browser. By default app will be server on `http://localhost:8080`.

## How it works

When you run dev server under the hood webpack "compiles" all packages, skins and generates sample host page with preconfigured platform and widgets.

Built code will have next structure:

```text
sbtech-sports-betting
├── ...
├── dist
│   ├── index.html                                          -- host page
│   ├── sbtech-widget-upcoming                              -- "compiled" widget
│   │   ├── locales                                         -- locales just copied as is
│   │   │   └── en.json                                    
│   │   ├── package.json
│   │   ├── sbtech-widget-upcoming.js                       -- it contains all code needed for widget except shared (like react, mobx)
│   │   ├── sbtech-widget-upcoming.js.map
│   │   └── skin                                            -- it contains all less files (including dependency) needed for skin development       
│   │       ├── palette-extension
│   │       │   └── variables.less
│   │       ├── skin.js
│   │       └── src
│   │           └── styles.less
│   ├── size-report.html
│   ├── size-report.json
│   └── skins                                               -- "compiled" skins
│       └── default                                         -- skin has name "default"
│           ├── sbtech-widget-upcoming.css                  -- it contains all styles needed for particular widget
│           └── sbtech-widget-upcoming.css.map
├── ...
```

When you open host page it loads widget, locale and skin from dist dir. For dev server dist dir is like a CDN. How hostpage know which widget to load and where to find its' assets? Let's look into html (code is prettified and simplified):

```html
<!DOCTYPE html>
<html lang="en">
...
<body class="sbtech">
    ...
    <div class="hostpage" data-tid="hostpage">
        <!--do not remove comment in following line, it is needed for widgets scafolding-->
        <!--widgets-->
        <div class="sbtech-widget-upcoming"></div>
    </div>
    <script src="sbtech-widgets-platform/lib/index.js"></script>
    <script>
        /*platform configuration*/
        SBTech.configure({
            tokenRenewInterval: 600000,
            skinsRootUrl: '/skins',
            skinName: 'default',
            locale: 'en',
            widgetRootUrl: ''
        })
 
        //do not remove comment in following line, it is needed for widgets scafolding
        /*widgets*/
        SBTech.addWidget('sbtech-widget-upcoming', 'sbtech-widget-upcoming', {}, {})   
    </script>
</body>
</html>
```

To build your own host page you need 3 simple steps:

Add platform script as the first script. For example: <script src="sbtech-widgets-platform/lib/index.js"></script>.
Configure the platform. Platform exposes global namespace `SBTech` which need to be used to share basic configuration across all widgtes. If you try to load any widget before platform configuration it will fail with error "Global configuration is missing". What could be configured:

```typescript
SBTech.configure({
    tokenRenewInterval = 600000                                 // required, how often in millisecond auth token will be renewed, it must be exposed as global var after authentication
    skinsRootUrl = '/skins'                                     // required, path to skins
    skinName = 'default'                                        // required, which skin to use
    skinsPathMask = '/${skinName}/${widgetName}.css'            // optional, mask used to find skins files, default: '/${skinName}/${widgetName}.css'
    localesRootUrl = ''                                         // required, path to locales
    locale = 'en'                                               // required, which locale to apply
    localesPathMask = '/${widgetName}/locales/${language}.json' // optional, mask used to find i18n files, default: '/${widgetName}/locales/${language}.json'
    fallbackLanguage = ''                                       // optional, fallback language, will be used if translation for main locale not found
    widgetRootUrl = ''                                          // required, path to widgets, url of widget will be '${widgetRootUrl}/${widgetName}/${widgetName}.js'
    timeZone = 0                                                // optional, date timezone, default: 0
    oddStyle = OddsStyle.FRACTIONAL                             // optional, odd styles, default: 'fractional'
})
```

Add the widget. Just simply call `addWidget` method:

```typescript
SBTech.addWidget(
    'sbtech-widget-upcoming',   // widget name
    'sbtech-widget-upcoming',   // placeholder className on the page, in sample it is <div class="sbtech-widget-upcoming"></div>
    {
        period: 24              // widget specific configuration
    },  
    {
        dontLoadLocales: true   // here you can specify some global overwrites (like widget or skin url) and few additonal options
    }
)
```

## Build an Upcoming widget

### Fetch sports

As we know how things work move on forward and fetch some data from Sports API. For upcoming widget we need list of sports that will start in next 24 hours.

First, we need to install sports api package. Go to project root and execute:

```shell
yarn add sbtech-sports-api
```

Sports API package is subscription based service. It exposes observable similar to `rxjs`. Under the hood it uses query language to collect needed data. The observable subject follows the contract as described here.

Now we are ready to write some service that will encapsulate fetching logic. Create new package, and name it for expample `sbtech-service-upcoming-data-api`. Project may look like:

```text
sbtech-sports-betting
├── ...
├── packages
│   ├── sbtech-service-upcoming-data-api
│       ├── README.md
│   │   ├── package.json
│   │   └── src
│   │       ├── index.ts
│   │       └── upcoming-data-api.ts
│   └── sbtech-widget-upcoming
│       ├── ...
├── ...
```

To check that service will work properly we declare and use class with fake data first. As Sports API is subscription based service we want to add streamed data helper that notify react component about changes. It's time to use `mobx`:

```typescript
import { observable, ObservableMap, action, computed } from 'mobx'
 
// We know that each entity of payload must have identifier
export interface IFeedEntity {
  id: string
}
 
// And we need some collector of payload updates and the single source of subscribed data
export interface IFeedCollector<T extends IFeedEntity> {
  values: T[]                   // here we will store actual state of subscribed data
 
  add(entity: T)                // with this methods we handle additons,
  change(entity: T)             // updates and removals of entities
  remove(entityId: string)      // from data stream
}
 
 
export class ObservableFeedCollector<T extends IFeedEntity> implements IFeedCollector<T> {
  // we need to notify react about changes in subscribed data
  // so we will use mobx observable map to store all actual entities of subscription
  private map: ObservableMap<T> = observable.shallowMap()
 
  // expose data from map as computed value,
  // as it's just easier to use array instead of map in react component
  @computed
  public get values(): T[] {
    return Array.from(this.map.values())
  }
 
  // each method that handle updates marked as action
  // it's how mobx know that something was changed 
  @action
  public add(entity: T) {
    this.map.set(entity.id, entity)
  }
 
  @action
  public change(entity: T) {
    this.map.set(entity.id, entity)
  }
 
  @action
  public remove(entityId: string) {
    this.map.delete(entityId)
  }
}
```

Upcoming data service then will look like this:

```typescript
import { entities, Observer } from 'sbtech-sports-api'                      // entities contains all types that API could return
import { IFeedCollector } from './feed-collector'
 
 
export class UpcomingDataApi {
  subscribeToSports(collector: IFeedCollector<entities.Sport>): Observer {    // this method subscribes to stream of upcoming sports
    const fakeSports: entities.Sport[] = [
      {
        id: '1',
        order: 0,
        name: 'Soccer',
        liveFixturesTotalCount: 1,
        fixturesTotalCount: 3,
        fixturesCount: 2,
        outrightsTotalCount: 0,
        entityType: 3,
      },
      {
        id: '2',
        order: 1,
        name: 'Basketball',
        liveFixturesTotalCount: 0,
        fixturesTotalCount: 2,
        fixturesCount: 2,
        outrightsTotalCount: 0,
        entityType: 3,
      }
    ]
 
    fakeSports.forEach(sport => collector.add(sport))
 
    return {
      unsubscribe() { }
    }
  }
}
```

```typescript
// Code is shortened for better readability
 
import { UpcomingDataApi, IFeedCollector, ObservableFeedCollector } from 'sbtech-service-upcoming-data-api'
import { entities, Observer } from 'sbtech-sports-api'
 
@observer
export class UpcomingWidgetComponent extends React.Component<UpcomingWidgetProps, {}> {
  private sportCollector: IFeedCollector<entities.Sport> = new ObservableFeedCollector()
  private sportSubscription: Observer
  private readonly upcominDataApi = new UpcomingDataApi()
 
  public componentWillMount() {
    // subscribe to upcoming sports stream before first render
    this.sportSubscription = this.upcominDataApi.subscribeToSports(this.sportCollector)
  }
 
  public componentWillUnmount() {
    // we need to unsubscribe from updates when component is not needed anymore
    this.sportSubscription.unsubscribe()
  }
 
  public render() {
    const { locale, translations: t } = this.props
 
    return (
      <Provider i18n={{ locale, translations: t }}>
        <div>
          <h1 data-tid={selectors.widget}>{t('title')}</h1>
          <div>
            {
              this.sportCollector.values.map(sport => (
                <div>{sport.name}</div>
              ))
            }
          </div>
        </div>
      </Provider>
    )
  }
}
```

Replace fake data with data from API:

```typescript
import { entities, Observer, ApiConfig, Query, Observable, ChangeFeedUpdate, Duration } from 'sbtech-sports-api'
import { appConfiguration, Config, AppConfiguration } from 'sbtech-widgets-platform'
import { IFeedCollector } from './feed-collector'
 
export class UpcomingDataApi {
  subscribeToSports(collector: IFeedCollector<entities.Sport>): Observer {
    const sportsApiRootUrl = 'https://ateam-dev2.staging.sbtech.com/api/{locale}/entities'
    const sportsPushApiRootUrl =  'https://ateam-dev2.staging.sbtech.com/signalr'
 
    // create Sports API config for particular endpoints
    const sportsConfig = ApiConfig.create(sportsApiRootUrl, sportsPushApiRootUrl)
 
    // get platform config (what we set using SBTech.configure)
    const globalConfig = Config.getConfiguration<AppConfiguration>(AppConfiguration)!
 
    // create query for upoming sports
    const query: Query = {
      query: 'Sports?$orderby=order',   // OData query for sports
      format: 'ODataV3',
      locale: globalConfig.locale,
      fastPreloadAmount: 10,            // how many entities will be fetched on first update
      duration: 'OneDay',               // recieve only upcoming data within one day
    }
 
    const observable = Observable.fromQuery(query, sportsConfig)
 
    // subscribe to data stream and notify react component through feed collector
    return observable
      .subscribe(({ payload }: ChangeFeedUpdate) => {
        const { add, change, remove } = payload
 
 
        add.forEach(entity => collector.add(entity))
        change.forEach(entity => collector.change(entity))
        remove.forEach(removeItem => collector.remove(removeItem.id))
      }, (error) => {
        console.error(error)
      })
  }
}
```

### Add styling

It's time to fetch game events for selected sport. We need to change our list of sports to radio group, so we can select only one sport at a time and add some simple styles.

Updated jsx:

```html
<div className={c('sports')}>
  {
    this.sportsCollector.values.map(sport => (
      <label className={c('sports-button')}>
        <input
          className={c('sports-radio')}
          type="radio"
          name="sport"
          value={sport.id}
        />
        <span className={c('sports-label')}>
          {sport.name}
        </span>
      </label>
    ))
  }
</div>
```

Corresponding styles:

```css
.sports
{
  display: flex;
 
 
  &-button
  {
    margin-right: 2px;
    margin-left: 2px;
    cursor: pointer;
 
    &:first-child
    {
      margin-left: 0;
    }
 
    &:last-child
    {
      margin-right: 0;
    }
  }
 
  &-radio
  {
    position: absolute;
    visibility: hidden;
  }
 
  &-label
  {
    display: block;
    padding: 8px 10px;
    border: 1px solid #000;
    border-radius: 4px;
  }
 
  &-radio:checked + &-label
  {
    background-color: #ccc;
  }
}
```

If you look into html you may notice that real CSS selector differ from selector used in jsx. For example <div className={c('sports')}> after render will be <div class="sbtech-widget-upcoming-styles__sports">. That's beacause we use CSS modules to add uniqueness to styles of each component and avoid possible collisions. Also we used small utility library `classnames` to map selector processed by css modules to jsx so the code looks clean and neet. Look into its' README on github for more information.

### Show sport events

Because we show events for particular sport we need to know which sport is selected, so let's extend our sport collector a little. Create wrapper over sport collector:

```typescript
import { observable, computed } from 'mobx'
import { entities, Observer } from 'sbtech-sports-api'
import { ObservableFeedCollector } from 'sbtech-service-upcoming-data-api'
 
 
export interface ISportListStore {
  readonly selectedSport: entities.Sport | null
  readonly sportList: entities.Sport[]
 
  selectSport(sportId: string): void
}
 
export class SportListStore implements ISportListStore {
  @observable
  private selectedSportId: string
 
  constructor(private sportCollector: ObservableFeedCollector<entities.Sport>) {      // inject previously created sport collector
  }
 
  public get sportList(): entities.Sport[] {                                            // for list of sport just return all values from collector
    return this.sportCollector.values
  }
 
  @computed
  public get selectedSport(): entities.Sport | null {                                   // that's how we expose selected sport, by default it is null
    return this.sportList.find(sport => sport.id === this.selectedSportId) || null
  }
 
  @action
  public selectSport(sportId: string) {                                                 // here we save currently selected sport and notify react components
    this.selectedSportId = sportId                                                      // basically we can omit action decorator here, as we change the only  
  }                                                                                     // observable value
}
```

And update widget component:

```typescript
// Code is shortened for better readability
 
import { ISportListStore, SportListStore } from './store/sport-list.store'
 
@observer
export class UpcomingWidgetComponent extends React.Component<UpcomingWidgetProps, {}> {
  private readonly sportCollector: ObservableFeedCollector<entities.Sport> = new ObservableFeedCollector()
  private readonly sportListStore: ISportListStore = new SportListStore(this.sportCollector)
  private readonly upcominDataApi = new UpcomingDataApi()
  private sportSubscription: Observer
 
  public componentWillMount() {
    this.sportSubscription = this.upcominDataApi.subscribeToSports(this.sportCollector)
  }
 
  public componentWillUnmount() {
    this.sportSubscription.unsubscribe()
  }
 
  public render() {
    // use selected sport id to check corresponding radio button
    const selectedSportId = this.sportListStore.selectedSport && this.sportListStore.selectedSport.id
 
    return (
      <Provider i18n={{ locale, translations: t }}>
        <div>
          <h1 data-tid={selectors.widget}>{t('title')}</h1>
          <div className={c('sports')}>
            {
              this.sportListStore.sportList.map(sport => (
                <label className={c('sports-button')}>
                  <input
                    className={c('sports-radio')}
                    type="radio"
                    name="sport"
                    value={sport.id}
                    checked={sport.id === selectedSportId}
                    onChange={this.onSelectSport}
                  />
                  <span className={c('sports-label')}>
                    {sport.name}
                  </span>
                </label>
              ))
            }
          </div>
        </div>
      </Provider>
    )
  }
 
  // that's how we handle selected sport   
  private onSelectSport = (event: React.FormEvent<HTMLInputElement>) => {
    this.sportListStore.selectSport(event.target.value)
  }
}
```

Next step is react on sport selection and subscribe to events of this sport. Let's update our upcoming api. To do so we will extract common code and add method for subcription for sport events. The result:

```typescript
import { entities, Observer, ApiConfig, Query, Observable, ChangeFeedUpdate, Duration } from 'sbtech-sports-api'
import { appConfiguration, Config, AppConfiguration } from 'sbtech-widgets-platform'
import { IFeedCollector } from './feed-collector'
 
export class UpcomingDataApi {
  subscribeToSports(collector: IFeedCollector<entities.Sport>): Observer {
    const query: IBaseQuery = {
      query: `Sports?$orderby=order`,
      duration: 'OneDay',
    }
 
    // we moved all the stuff about configuration and creatin of observable
    // into separate function
    const observable = createObservable(query)
 
    // also we extracted subscription handling
    return subscribeObservable(observable, collector)
  }
 
  // that's our new subscription to events of particular sports within 24 hours
  public subscribeToSportEvents(sportId: string, collector: IFeedCollector<entities.SportEvent>) {
    const query: IBaseQuery = {
      query: `Events?$filter=sportId='${sportId}' and isLive eq false`, // filter events by sport id and by live status
      duration: 'OneDay',                                               // also limit by time period
    }
 
    const observable = createObservable(query)
 
    return subscribeObservable(observable, collector)
  }
}
 
 
// you may want to move this code into separate files,
// we kept it here for readability
interface IBaseQuery extends Partial<Query> {
  query: string
}
 
function createObservable(query: IBaseQuery): Observable {
  const sportsApiRootUrl = 'https://ateam-dev2.staging.sbtech.com/api/{locale}/sportsdata/v1'
  const sportsPushApiRootUrl = 'https://ateam-dev2.staging.sbtech.com/signalr'
  const sportsConfig = ApiConfig.create(sportsApiRootUrl, sportsPushApiRootUrl)
  const globalConfig = Config.getConfiguration<AppConfiguration>(AppConfiguration)!
 
  const baseQuery: Query = {
    format: 'ODataV3',
    locale: globalConfig.locale,
    fastPreloadAmount: 10,
    ...query
  }
 
  return Observable.fromQuery(baseQuery, sportsConfig)
}
 
function subscribeObservable(observable: Observable, collector: IFeedCollector<any>) {
  return observable.subscribe(({ payload }: ChangeFeedUpdate) => {
    const { add, change, remove } = payload
 
    add.forEach(entity => collector.add(entity))
    change.forEach(entity => collector.change(entity))
    remove.forEach(removeItem => collector.remove(removeItem.id))
  }, (error) => {
    console.error(error)
  })
}
```

We are now able to subscribe to events. We can do so directly in sport select callback, but here we use another solution - create mobx reaction:

```typescript
@observer
export class UpcomingWidgetComponent extends React.Component<UpcomingWidgetProps, {}> {
  private eventCollector: ObservableFeedCollector<entities.SportEvent>
  private disposeSportChangeReaction: IReactionDisposer
  private eventSubscription?: Observer
 
  public componentWillMount() {
    // start waiting for sport selection, we don't need to wait for sport data first, reactive power!
    this.disposeSportChangeReaction = this.createSportChangeReaction()
    this.sportSubscription = this.upcominDataApi.subscribeToSports(this.sportCollector)
  }
 
  public componentWillUnmount() {
    this.sportSubscription.unsubscribe()
 
    // free up resource when thay are not needed
    if (this.eventSubscription) {
      this.eventSubscription.unsubscribe()
    }
 
    this.disposeSportChangeReaction()
  }
 
  // Here we declare reaction that watches for changes of selected sport
  // when we change the sport we start collecting events for this sport
  private createSportChangeReaction(): IReactionDisposer {
    // That's expression to be watched, we watch id instead the whole object to not make deep comparation
    const sportIdExpression = () => this.sportListStore.selectedSport && this.sportListStore.selectedSport.id
 
    return reaction(sportIdExpression, (sportId: string) => {
      // create event collector for newly created sport
      // here we use single property for any sport and clear previously collected
      // but we cache previously collected events if need by creating some map with relation sportId <-> events
      this.eventCollector = new ObservableFeedCollector<entities.SportEvent>()
 
      // unsubscibe from previus sport events, we don't need this connection anymore
      if (this.eventSubscription) {
        this.eventSubscription.unsubscribe()
      }
 
      // and subscribe to new one
      this.eventSubscription = this.upcominDataApi.subscribeToSportEvents(sportId, this.eventCollector)
    })
  }
}
```

Now we able to add markup and some styles for collected events:

```typescript
@observer
export class UpcomingWidgetComponent extends React.Component<UpcomingWidgetProps, {}> {
  public render() {
    return (
      <Provider i18n={{ locale, translations: t }}>
        <div>
          <div className={c('events')}>
            {
              this.eventCollector
                ?
                this.eventCollector.values.map(event => (
                  <div key={event.id} className={c('events-card')}>
                    <div className={c('events-card-name')}>
                      {event.eventName || event.participants.map(p => p.name).join(' - ')}
                    </div>
                    <div className={c('events-card-time')}>
                      {new Date(event.startEventDate).toLocaleString()}
                    </div>
                  </div>
                ))
                :
                null
            }
          </div>
        </div>
      </Provider>
    )
  }
}
```

Styles:

```css
.events
{
  display: flex;
  flex-direction: column;
 
 
  &-card
  {
    display: flex;
    align-items: center;
    flex: 1;
    width: 745px;
    padding: 8px 10px;
    border: 1px solid #000;
 
    &-name
    {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
 
    &-time
    {
      font-weight: 700;
    }
  }
}
```

And finally how everything looks toogether:

That's it, we created simple, but fully functional implementation of an "Upcoming events" widget.